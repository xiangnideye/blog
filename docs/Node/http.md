# HTTP  
记录了和HTTP相关的一些问题，如果查找和HTTP相关的问题都在此记录

## HTTP缓存
> 每次请求不用都去服务器拉取最新资源，可以节省性能。避免多次重复请求;  
> 首页不能设置缓存，如果你设置了，那么用户的得不到最新的响应，不能获取到你的最新网页;  
> 减少了服务器的负担，大大提高了网站性能;    
> 加快了客户端加载网页的速度;  
 

### 缓存机制
HTTP缓存相当于客户端缓存，浏览器会有一个缓存数据库，用于存储一些不经常变化的静态文件；

**强制缓存**

当缓存数据库中有请求所需要的文件或者数据的时候，客户端会直接从缓存数据库中获取数据，当缓存数据库中没有需要的数据的时候，才会发送请求从服务端获取；  
优先级高于协商缓存

**协商缓存**

又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的对比标识，拿到标识后去服务端验证是否失效，如果服务端验证没有失效则返回状态码304，此时客户端会再去使用缓存数据库中的数据，如果失效，服务端会返回最新数据；

### 缓存方案

> 1. 强制缓存
#### Cache-Control
Cache-Control 通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的, 这意味着在请求设置的指令，在响应中不一定包含相同的指令。
是Expiress的升级版  

Cache-Control 常见状态：
- no-cache: 告诉服务器不直接使用缓存，要求向原服务器发起请求（表示每次请求都向服务器发起请求，需要使用协商缓存来验证缓存数据）
- no-store: 所有内容都不会被保存或者缓存下来（表示浏览器不进行缓存，所有内容都不会缓存） 
- max-age: 缓存的内容在多少秒后失效

#### Expiress
Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。  

```
  如何在服务端设置缓存时间(强制缓存)

  response.setHeader('Expiress', new Date(Date.now() + 10 * 1000).toGMTString());
  response.setHeader('Cache-Control', max-age: 1000);

  Cache-Control是Expiress的升级版，如果设置了max-age就会忽略Expiress;
```

> 2. 协商缓存
#### Last-Modified
判断文件最后修改时间；服务器在响应请求的时候会告诉浏览器资源的最后修改时间。浏览器再次请求服务器的时候，请求头会包含此字段（if-Modified-Since:），记录了缓存中获取资源的最后修改时候。服务端会进行判断。如果时间一致就返回304状态码。

#### Etag
根据资源生成一个MD5唯一标识，也叫指纹；浏览器再次访问的时候会携带此表示。服务器会进行对比。如果一致返回304；



## 从输入URL到页面渲染经历了什么
主要涉及两个部分：
- 网络请求
- 页面渲染

### 网络请求
**1. DNS域名解析**  
- DNS 通过域名去查找IP地址；

**2. TCP连接 三次握手**  
- 1. 由浏览器发起：表示我要发送请求了
- 2. 由服务端发起：表示我准备接收了。你可以发送了
- 3. 由浏览器发起：表示我马上就发，你准备接收吧  

**3. 发送HTTP请求**  
- 开始发送HTTP请求

**4. 服务器处理HTTP请求并返回报文**  
**5. 页面渲染**  
**6. 断开连接TCP四次挥手**  
- 1. 浏览器发起：我请求报文发送完毕，你准备关闭把；
- 2. 服务器发起：我请求报文接收完毕，我准备关闭，你也准备吧；
- 3. 服务器发起：我响应报文发送完毕，你准备关闭把；
- 4. 浏览器发起：我响应报文接收完毕，我准备关闭，你也准备把；

### 页面渲染
**1. 生成DOM树** 
- DOM的结构是由各种子节点组成的，那么以HTMLDocument为根节点，其余节点为子节点，那么组织成的树型数据结构的表示就是DOM树。

- 生成DOM树的大概步骤：
1. 将字节流转换成字符流，根据不同的编码进行解码
2. 通过词法分析将字符流解析为一个个词语（Token）。这个过程会跳过空格与换行内容。词法分析由HTMLTokenizer完成。
3. 使用XSSAuditor来进行词语验证及过滤，主要是出于安全方面的考虑
4. 在经过XSSAuditor过滤之后，由解释器调用方法构建DOM节点
5. 从上面的DOM节点构建出来DOM树，包括创建元素节点的属性节点工作  

**2. 生成CSS规则树**
1. CSS是一种渲染阻塞资源(render blocking resource)，**它需要完全被解析完毕之后才能进入生成渲染树的环节**。  
2. 因为CSS具有继承属性， 后面定义的样式会覆盖或者修改前面的样式。如果我们只使用样式表中部分解析好的样式，我们可能会得到错误的页面效果。所以，我们只能等待CSS完全解析之后，才能进入关键渲染路径的下一环节。
3. CSSOM树在构建过程中会阻塞页面的渲染，**但是不会阻塞DOM的解析。因为DOM树与CSSOM树的解析生成是独立的，在生成过程中无需阻塞DOM解析**。

**3. JavaScript的解析**
1. **会阻塞DOM的解析，因为在JS中可以操作DOM来修改DOM结构，所以遇到外链脚本或者script标签的时候需要等待这部分代码执行完成才会继续解析DOM**
2. 可以采用增加defer或者async属性来改变脚本的执行顺序，使其延迟执行；

**4. DOM树 + CSS规则树 = render树**
1. 当DOM树与CSSOM树构建完成后，浏览器会将两者进行结合，生成渲染树，这棵树包含了页面所有可见元素及其渲染信息。浏览器会根据渲染树中的样式以及设备的屏幕尺寸，来计算每个元素的坐标和大小。  
2. **回流（重排）：** 当对DOM的修改引发了DOM几何尺寸的变化，（修改宽高，隐藏显示等），此时浏览器会重新计算元素的几何属性，然后在将计算后的结果绘制出来。
3. **重绘：** 对DOM修改了样式上的变化，但是没有影响元素的几何属性，（修改背景颜色等），这个时候浏览器不会重新计算元素的几何属性，而是直接给该元素修改样式，所以叫重绘。
4. 重绘不一定会导致回流，但是回流一定会导致重绘
5. 优化点：
- DOM离线： 如果元素为display: none;那么后续的操作都不会引发回流和重绘，但是隐藏和显示会触发。只是节约中间次数；
- JS缓存：将初始样式获取到进行变量赋值，然后操作之前缓存的变量。最后统一修改；
- 文档碎片





