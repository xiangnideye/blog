# 网络应用相关  
记录了和HTTP相关的一些问题，如果查找和HTTP相关的问题都在此记录

## HTTP缓存
> 每次请求不用都去服务器拉取最新资源，可以节省性能。避免多次重复请求;  
> 首页不能设置缓存，如果你设置了，那么用户的得不到最新的响应，不能获取到你的最新网页;  
> 减少了服务器的负担，大大提高了网站性能;    
> 加快了客户端加载网页的速度;  
 

### 缓存机制
HTTP缓存相当于客户端缓存，浏览器会有一个缓存数据库，用于存储一些不经常变化的静态文件；

**强制缓存**

当缓存数据库中有请求所需要的文件或者数据的时候，客户端会直接从缓存数据库中获取数据，当缓存数据库中没有需要的数据的时候，才会发送请求从服务端获取；  
优先级高于协商缓存

**协商缓存**

又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的对比标识，拿到标识后去服务端验证是否失效，如果服务端验证没有失效则返回状态码304，此时客户端会再去使用缓存数据库中的数据，如果失效，服务端会返回最新数据；

### 缓存方案

> 1. 强制缓存
#### Cache-Control
Cache-Control 通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的, 这意味着在请求设置的指令，在响应中不一定包含相同的指令。
是Expiress的升级版  

Cache-Control 常见状态：
- no-cache: 告诉服务器不直接使用缓存，要求向原服务器发起请求（表示每次请求都向服务器发起请求，需要使用协商缓存来验证缓存数据）
- no-store: 所有内容都不会被保存或者缓存下来（表示浏览器不进行缓存，所有内容都不会缓存） 
- max-age: 缓存的内容在多少秒后失效

#### Expiress
Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。  

```
  如何在服务端设置缓存时间(强制缓存)

  response.setHeader('Expiress', new Date(Date.now() + 10 * 1000).toGMTString());
  response.setHeader('Cache-Control', max-age: 1000);

  Cache-Control是Expiress的升级版，如果设置了max-age就会忽略Expiress;
```

> 2. 协商缓存
#### Last-Modified
判断文件最后修改时间；服务器在响应请求的时候会告诉浏览器资源的最后修改时间。浏览器再次请求服务器的时候，请求头会包含此字段（if-Modified-Since:），记录了缓存中获取资源的最后修改时候。服务端会进行判断。如果时间一致就返回304状态码。

#### Etag
根据资源生成一个MD5唯一标识，也叫指纹；浏览器再次访问的时候会携带此表示。服务器会进行对比。如果一致返回304；



## 从输入URL到页面渲染经历了什么
主要涉及两个部分：
- 网络请求
- 页面渲染

### 网络请求
**1. DNS域名解析**  
- DNS 通过域名去查找IP地址；

**2. TCP连接 三次握手**  
- 1. 由浏览器发起：表示我要发送请求了
- 2. 由服务端发起：表示我准备接收了。你可以发送了
- 3. 由浏览器发起：表示我马上就发，你准备接收吧  

**3. 发送HTTP请求**  
- 开始发送HTTP请求

**4. 服务器处理HTTP请求并返回报文**  
**5. 页面渲染**  
**6. 断开连接TCP四次挥手**  
- 1. 浏览器发起：我请求报文发送完毕，你准备关闭把；
- 2. 服务器发起：我请求报文接收完毕，我准备关闭，你也准备吧；
- 3. 服务器发起：我响应报文发送完毕，你准备关闭把；
- 4. 浏览器发起：我响应报文接收完毕，我准备关闭，你也准备把；

### 页面渲染
**1. 生成DOM树** 
- DOM的结构是由各种子节点组成的，那么以HTMLDocument为根节点，其余节点为子节点，那么组织成的树型数据结构的表示就是DOM树。

- 生成DOM树的大概步骤：
1. 将字节流转换成字符流，根据不同的编码进行解码
2. 通过词法分析将字符流解析为一个个词语（Token）。这个过程会跳过空格与换行内容。词法分析由HTMLTokenizer完成。
3. 使用XSSAuditor来进行词语验证及过滤，主要是出于安全方面的考虑
4. 在经过XSSAuditor过滤之后，由解释器调用方法构建DOM节点
5. 从上面的DOM节点构建出来DOM树，包括创建元素节点的属性节点工作  

**2. 生成CSS规则树**
1. CSS是一种渲染阻塞资源(render blocking resource)，**它需要完全被解析完毕之后才能进入生成渲染树的环节**。  
2. 因为CSS具有继承属性， 后面定义的样式会覆盖或者修改前面的样式。如果我们只使用样式表中部分解析好的样式，我们可能会得到错误的页面效果。所以，我们只能等待CSS完全解析之后，才能进入关键渲染路径的下一环节。
3. CSSOM树在构建过程中会阻塞页面的渲染，**但是不会阻塞DOM的解析。因为DOM树与CSSOM树的解析生成是独立的，在生成过程中无需阻塞DOM解析**。

**3. JavaScript的解析**
1. **会阻塞DOM的解析，因为在JS中可以操作DOM来修改DOM结构，所以遇到外链脚本或者script标签的时候需要等待这部分代码执行完成才会继续解析DOM**
2. 可以采用增加defer或者async属性来改变脚本的执行顺序，使其延迟执行；

**4. DOM树 + CSS规则树 = render树**
1. 当DOM树与CSSOM树构建完成后，浏览器会将两者进行结合，生成渲染树，这棵树包含了页面所有可见元素及其渲染信息。浏览器会根据渲染树中的样式以及设备的屏幕尺寸，来计算每个元素的坐标和大小。  
2. **回流（重排）：** 当对DOM的修改引发了DOM几何尺寸的变化，（修改宽高，隐藏显示等），此时浏览器会重新计算元素的几何属性，然后在将计算后的结果绘制出来。
3. **重绘：** 对DOM修改了样式上的变化，但是没有影响元素的几何属性，（修改背景颜色等），这个时候浏览器不会重新计算元素的几何属性，而是直接给该元素修改样式，所以叫重绘。
4. 重绘不一定会导致回流，但是回流一定会导致重绘
5. 优化点：
- DOM离线： 如果元素为display: none;那么后续的操作都不会引发回流和重绘，但是隐藏和显示会触发。只是节约中间次数；
- JS缓存：将初始样式获取到进行变量赋值，然后操作之前缓存的变量。最后统一修改；
- 文档碎片

## TCP 
- 七层网络协议
  1. 物理层
    - 硬件相关
  2. 数据链路层
  3. 网络层
  4. 传输层
  5. 会话层
  6. 表
  7. 应用层  

- 一个TCP包最多能传递1460个字节，头部最多能传递20个字节
- http请求在chrome下最多是6个（同一个域名）会有**队头阻塞**问题
- **滑动窗口**
  - 指的是发送方和接收方都有一个窗口用来接受数据和发送数据。以接收方为主，如果发送方发送的窗口大于接收方的窗口，就会停止接受，此时发送方会不断的发送测试包来测试接收方的窗口是否还有剩余。接收方最大是65535
  - **Nagle算法**，定义**任意时刻，最多只能有一个未被确认的小段**，就是任意时刻，只能接收一个发送字段，如果发送字段未被确认，那么发送方后面的就会等待，并且自动合并成一个字段用于下次再发送（缺点是如果接收方确认的很快，后面的字段来不及合并就发送了）
  - **Cork算法**，就是指的发送的值必须到达最大值，然后再发送（就是装满了再发）
- **拥塞处理**
  - **慢启动，拥塞避免，快从传和快恢复**，tcp维护一个拥塞窗口(cwnd),在传输过程中，如果没有拥塞就将此值增大，如果出现拥塞就减小
    - cwnd < ssthresh 使用慢开始算法
    - cwnd > ssthresh 使用拥塞避免算法
    - **Tahoe版本**：慢启动指数规律增长（2,4,8...），等达到预期之后会开启拥塞避免，变成慢增长；等到网络拥塞之后，就恢复慢开始从新继续
  - **Reno算法**
    - 快重传，指的是发送的过程中出现丢包的情况，此时不要立即回退到慢开始阶段，而是对已经收到的报文重复确认，如果确认次数达到三次，就立即进行重传，快恢复算法，降低充值cwnd的频率

## CDN
  - 就近访问，强缓存   

## HTTPS

### 1. 什么是HTTPS
HTTPS可以理解为：
> HTTPS = HTTP + TLS/SSL

HTTPS的工作流程：  
1. 客户端首先向服务端发送一个HTTPS请求
2. 服务端会把事先配置好的公钥证书随着其它的信息返回给客户端
3. 客户端在收到服务端发来的证书之后进行验证，验证的过程参考数字证书验证，会得到服务端的信息以及它的公钥
4. 验证成功之后生成一个叫做 client_params 的参数发送给服务器；同时自己会用伪随机函数生成一个 secret，这个secret就是它们后续进行通信的对称密钥。
5. 服务器在收到刚刚的 client_params之后，也会根据伪随机函数生成一个secret。这时候双方都有了相同的对称密钥。
6. 后面的传输都会用这个 secret 进行对称密钥加解密传输


### 2. HTTPS解决了什么问题
- 信息窃听
  - 对称加密：用来对信息进行加密，防止信息被窃听。也就是信息加密
- 信息篡改
  - 数字签名：用来验证信息完整性，防止信息被更改。也就是完整性校验
- 信息劫持
  - 数字证书：用来实现身份认证和秘钥协商，防止信息来源被修改。也就是身份验证

### 3. HTTP和HTTPS的区别
- HTTPS标准端口443，HTTP是80
- HTTPS基于传输层，HTTP基于应用层
- 信息加密，HTTPS保证了信息的安全性，HTTP是明文传输

### 4. 解决办法
#### 对称加密
采用对称加密算法，是最简单的加密方式，指的是加密解密都用相同的秘钥  
优点是加解密的速快，缺点是不安全，只要拿到秘钥任何人都能解密

#### 非对称加密
使用一对非对称的秘钥，就是一把公钥，一把私钥；用公钥加密的只有用私钥解密，用私钥加密的只有用公钥解密  
优点是传输的内容不能被破解  

缺点：  
1、公钥是公开的，谁都可以获取，如果是用私钥进行加密，那么用公钥就可以解密  
2、公钥并不包含服务器的信息，这样并不能保证服务器身份的合法性，可能存在中间人攻击，也就是服务器发送给客户端的公钥可能在中途被截获篡改  
3、数据加解密的时候需要消耗一定的时间，降低了数据的传输效率

#### 混合加密

> HTTPS采用了混合加密的方式 

概念：结合两种加密方式的优点，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式。

流程：发送密文的一方用**对方的公钥**进行加密处理**对称的秘钥**，然后对方接收到之后用自己的私钥进行解密得到**对称的秘钥**，这样就达到了确保交换的秘钥是安全的前提下使用对称加密方式进行通信 

也就是说A用B的公钥加密对称秘钥，这样只有B用自己的私钥可以解开A加密的密文，得到对称秘钥，然后A和B就可以用对称秘钥进行加密通信了

缺点：  
1、只能解决信息不被窃听的问题  
2、无法解决信息的完整性也就是信息是否被篡改

### 5. 数字签名
#### 数字签名的作用
- 用来保证信息的完整性  
- 确定信息确实是发送方签名并且发出来

#### 数字签名过程
1. 将信息原文用hash函数生成一个叫消息摘要的东西
2. 将信息摘要用发送方的私钥进行加密
3. 然后将加密后的信息和原文一起发送给接收者

#### 验证签名的过程
1. 发送方把原文用Hash函数进行处理后得到消息摘要，然后用自己的私钥进行加密，然后把加密后的信息摘要和原文一起发送给接收方
2. 接收方收到原文和加密后的信息摘要
3. 接收方用Hash函数对原文进行处理得到消息摘要
4. 接收方用发送方的公钥对信息摘要进行解密得到一份信息摘要
5. 比较这两份信息摘要是否相同，就可以验证出数据有没有被篡改

### 6. 数字证书
#### 数字证书的作用
- 数字证书也叫公钥证书，主要是为了解决通信方身份遭伪装的问题，也就是验证通信方的身份

#### 数字证书的颁发流程
1. 服务器的运营人员会向认证机构提交自己的公钥、组织信息、个人信息等并申请认证
2. 认证机构在拿到这些信息后会通过线上、线下各种途径验证申请者提交信息的真实性
3. 在确认其真实性后，认证机构给这些信息(申请者的公钥，组织信息，个人信息以及认证机构自己的信息等)，我们简称为明文信息，进行数字签名，过程也就是签名提到的数字签名的步骤
  - 通过Hash函数处理明文信息生成一个信息摘要
  - 再用认证机构自己的私钥对信息摘要进行加密处理
  - 通过这两个步骤生成的文件就叫数字签名
4. 之后会将明文信息和数字签名组合而成的证书颁发给申请者，也就是服务器

#### 为什么说数字证书能验证通信方的身份
- 因为客户端在第一次请求服务器的时候，服务器会把证书给客户端
- 客户端拿到证书之后会验证这个证书
  1. 用Hash函数对信息处里获得信息摘要
  2. 用浏览器内置的CA机构的公钥进行对证书的解密，获取信息摘要
  3. 两份信息摘要进行对比
  4. 验证不仅仅是数字签名的验证，还会验证证书相关的域名信息，有效时间，是否在吊销列表中，以及上一级是否有效等





